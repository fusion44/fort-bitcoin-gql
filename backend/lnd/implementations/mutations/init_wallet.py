"""Implementation for the init wallet mutation"""
import json
import pathlib
import time

import graphene
import grpc
from django.db.models import QuerySet
from google.protobuf.json_format import MessageToJson

import backend.lnd.rpc_pb2 as ln
import backend.lnd.rpc_pb2_grpc as lnrpc
from backend.error_responses import ServerError, Unauthenticated
from backend.lnd.models import LNDWallet
from backend.lnd.types import LnInfoType
from backend.lnd.utils import (build_grpc_channel_manual,
                               build_lnd_wallet_config, process_lnd_doc_string)


class InitWalletSuccess(graphene.ObjectType):
    info = graphene.Field(LnInfoType)


class InitWalletInstanceNotFound(graphene.ObjectType):
    error_message = graphene.String(
        default_value="No wallet instance found for User")
    suggestions = graphene.String(
        default_value=
        "Use createLightningWallet and lnInitWallet to create the wallet")


class InitWalletPasswordToShortError(graphene.ObjectType):
    error_message = graphene.String(
        default_value="Password must have at least eight character")


class InitWalletIsInitialized(graphene.ObjectType):
    error_message = graphene.String(
        default_value="Wallet is already fully initialized")


class InitWalletError(graphene.ObjectType):
    error_message = graphene.String()


class InitWalletPayload(graphene.Union):
    class Meta:
        types = (Unauthenticated, ServerError, InitWalletInstanceNotFound,
                 InitWalletPasswordToShortError, InitWalletError,
                 InitWalletIsInitialized, InitWalletSuccess)


class InitWalletMutation(graphene.Mutation):
    class Arguments:
        """The arguments class for the mutation"""
        wallet_password = graphene.String(
            required=True,
            description=
            "The passphrase that should be used to encrypt the wallet. This MUST be at least 8 chars in length. After creation, this password is required to unlock the daemon."
        )
        cipher_seed_mnemonic = graphene.List(
            graphene.String,
            description=
            "A 24-word mnemonic that encodes a prior aezeed cipher seed obtained by the user. This may have been generated by the GenSeed method, or be an existing seed."
        )
        aezeed_passphrase = graphene.String(
            description=
            "An optional user provided passphrase that will be used to encrypt the generated aezeed cipher seed."
        )
        recovery_window = graphene.Int(
            description=
            "An optional argument specifying the address lookahead when restoring a wallet seed. The recovery window applies to each invdividual branch of the BIP44 derivation paths. Supplying a recovery window of zero indicates that no addresses should be recovered, such after the first initialization of the wallet."
        )

    Output = InitWalletPayload

    @staticmethod
    def description():
        """Returns the description for this mutation. 
        The String is fetched directly from the lnd grpc package
        """
        return process_lnd_doc_string(
            lnrpc.WalletUnlockerServicer.InitWallet.__doc__)

    def mutate(self,
               info,
               wallet_password: str,
               cipher_seed_mnemonic: [] = None,
               aezeed_passphrase: str = None,
               recovery_window: int = None):
        """https://api.lightning.community/?python#initwallet"""

        if not info.context.user.is_authenticated:
            return Unauthenticated()

        if len(wallet_password) < 8:
            return InitWalletPasswordToShortError()

        res: QuerySet = LNDWallet.objects.filter(owner=info.context.user)

        if not res:
            return InitWalletInstanceNotFound()

        wallet: LNDWallet = res.first()
        if wallet.initialized:
            return InitWalletIsInitialized()

        res = init_wallet_mutation(wallet, wallet_password,
                                   cipher_seed_mnemonic, aezeed_passphrase,
                                   recovery_window)

        if isinstance(res, InitWalletSuccess):
            wallet.initialized = True
            wallet.save()

        return res


def init_wallet_mutation(wallet: LNDWallet, wallet_password: str,
                         cipher_seed_mnemonic: [], aezeed_passphrase: str,
                         recovery_window: int) -> LnInfoType:
    cfg = build_lnd_wallet_config(wallet.pk)

    channel_data = build_grpc_channel_manual(
        rpc_server="127.0.0.1",
        rpc_port=cfg.rpc_listen_port_ipv4,
        cert_path=cfg.tls_cert_path,
    )

    if channel_data.error is not None:
        return channel_data.error

    # init wallet
    stub = lnrpc.WalletUnlockerStub(channel_data.channel)
    request = ln.InitWalletRequest(
        wallet_password=wallet_password.encode(),
        cipher_seed_mnemonic=cipher_seed_mnemonic,
        aezeed_passphrase=aezeed_passphrase.encode()
        if aezeed_passphrase is not None else None,
        recovery_window=recovery_window)
    try:
        response = stub.InitWallet(
            request, metadata=[('macaroon', channel_data.macaroon)])

        # LND requires some time seconds to startup.
        # So, check until the macaroon files exist and then return
        # TODO: find a better solution to this
        file = pathlib.Path(cfg.read_only_macaroon_path)
        while 1:
            if file.is_file():
                break
            time.sleep(2)
        time.sleep(5)
    except grpc.RpcError as exc:
        # pylint: disable=E1101
        print(exc)
        return ServerError.generic_rpc_error(exc.code(), exc.details())

    # Need to rebuild channel data because the macaroons
    # are only generated upon wallet initialization
    channel_data = build_grpc_channel_manual(
        rpc_server="127.0.0.1",
        rpc_port=cfg.rpc_listen_port_ipv4,
        cert_path=cfg.tls_cert_path,
        macaroon_path=cfg.admin_macaroon_path)

    stub = lnrpc.LightningStub(channel_data.channel)
    request = ln.GetInfoRequest()

    try:
        response = stub.GetInfo(
            request, metadata=[('macaroon', channel_data.macaroon)])
    except grpc.RpcError as exc:
        print(exc)
        return ServerError.generic_rpc_error(exc.code, exc.details)  # pylint: disable=E1101

    json_data = json.loads(
        MessageToJson(
            response,
            preserving_proto_field_name=True,
            including_default_value_fields=True,
        ))
    return InitWalletSuccess(info=LnInfoType(json_data))
